# Failure Handling and Error Reporting
This document describes the responsibilities in handling failures and reporting non-fatal errors to Crashlytics.  
Although Crashlytics allows applications to report both fatal and non-fatal errors, Mintee's error reporting and handling architecture is designed such that fatal errors are __NEVER__ issued.  
The following definitions are used as such throughout the document:  
* __Failure__: A code execution that has resulted in an error that cannot be corrected by user action.

# Table of Contents
1. [Failure handling and error reporting](#failure-handling-and-error-reporting)
    * [Base debug objects](#base-debug-objects)
1. [Crashlytics configurations](#crashlytics-configurations)
1. [Build versioning](#build-versioning)

# Failure handling and error reporting
All failures are [reported to Crashlytics](#error-reporting) using the `ErrorManager` utility. After finding and reporting an error, failable functions notify callers of failures by either return optionals or throwing errors. Generally, failable functions adhere to the following:  
- Report and throw error if there are multiple possible reasons for failure.
- Report error and return optional if there is only one possible reason for failure.
  
__Note__  
View components are __NEVER__ responsible for actually reporting errors to Crashlytics. When accessing optional data or calling failable functions, View components should use helper functions that report the error.  
View components (and their completion handlers) are only responsible for presenting error alerts to the user after being notified of failure by helper functions.

## Base debug objects
When a failure occurs in a model component, error reporting, in addition to relevant debug data, uses APIs provided by certain model components (base objects) to report an additional set of standard debug data.  
If the base debug object is unavailable (ex. failure occurs in a model component initializer), as much debug data is reported as possible/needed.  
The following table specifies base objects for each of Mintee's model components.
| Model component | Is base object? | Base debug object |
|-|-|-|
| Task | Y | N/A |
| Analysis | Y | N/A |
| Tag | N | None |
| TaskInstance | N | Task |
| TaskTargetSet | N | Task |
| TaskSummaryAnalysis | N | Task |
| LegendEntry | N | Analysis |
| DayPattern | N | Task |

# Crashlytics configurations
In order to separate testing and release data, Mintee uses the following build phases and configurations to capture data in 2 separate Firebase applications:  
1. The `Copy Bundle Resources` build phase copies both plists for the 2 Firebase applications to the built product bundle.
1. The `Update GoogleService-Info.plist` build phase copies and renames the appropriate Firebase plist to `GoogleService-Info.plist` in the built bundle. The resulting `.app` reports data to Firebase based on the following:  
    * Builds that use `GoogleService-Info-Debug.plist` report to Firebase application `Leko-Mintee (debug)`
    * Builds that use `GoogleService-Info-Release.plist` report to Firebase application `Leko-Mintee`

# Build versioning
To correlated reported errors with source code version, Mintee largely follows [Twitch's iOS versioning practices](https://blog.twitch.tv/en/2016/09/20/ios-versioning-89e02f0a5146/).
Mintee generates and updates the app's build version everytime the project is archived for distribution. This is achieved by the following build phases, targets, scripts, and configurations:  
1. Mintee preprocesses `Info.plist` by defining the following project-wide build settings:
    * `INFOPLIST_PREFIX_HEADER` = `${PROJECT_DIR}/Versions/versions.h`
    * `INFOPLIST_PREPROCESS` = `Yes`
1. Mintee's `Info.plist` sets the property `CFBundleVersion` to value `MinteeBuildNumber` (to be preprocessed).
1. Mintee's target dependency `Versions` is built before Mintee is. `Versions` contains the `Update build versions` run script phase, which generates a `versions.h` header file.
    * The `versions.h` contains a single preprocessor directive that defines the token `MinteeBuildNumber`, thus keeping up to date the `Info.plist` distributed with Mintee. `MinteeBuildNumber` is generated by concatenating the short commit version of the current branch's tip, `.`, and the current epoch in minutes.

__Notes__
* XCode actions using the `Debug` build configuration have, at times, not updated the Version number (unless a full clean and rebuild is executed). The exact issue and solution has not been found. The following (potential) workarounds are recommended to have the `Debug` build configuration generate a new version number for each build:  
    * In your machine's XCode developer dir, delete the `DerivedData` dir.
* For builds that use the `Release` configuration, the `Check Git changes` build phase of `Versions` is used to verify that the current branch is up-to-date with and tracking `origin/master`, with no merge conflicts or uncommitted changes.